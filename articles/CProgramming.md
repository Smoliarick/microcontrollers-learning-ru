<h1>Шпаргалка по C</h1>

<h1>Содержание</h1>

- [Установка компилятора для C](#установка-компилятора-для-c)
- [Hello, World и процесс запуска программы](#hello-world-и-процесс-запуска-программы)
- [Имена переменных](#имена-переменных)
- [Типы данных и их размеры](#типы-данных-и-их-размеры)
  - [Суффиксы для типов данных](#суффиксы-для-типов-данных)
  - [Спецификаторы для вывода чисел в консоль в функции `printf`](#спецификаторы-для-вывода-чисел-в-консоль-в-функции-printf)
  - [Представление числа в различных системах](#представление-числа-в-различных-системах)
  - [Определение размера типов данных](#определение-размера-типов-данных)
- [Управляющие последовательности](#управляющие-последовательности)
- [Константы](#константы)
  - [Строковые константы](#строковые-константы)
  - [Константы перечислимого типа](#константы-перечислимого-типа)
- [Объявление и инициализация](#объявление-и-инициализация)
  - [Модификатор `const`](#модификатор-const)
- [Операции](#операции)
  - [Арифметические операции](#арифметические-операции)
  - [Операции отношения и логические операции](#операции-отношения-и-логические-операции)
  - [Операции инкрементирования и декрементирования](#операции-инкрементирования-и-декрементирования)
  - [Поразрядные операции](#поразрядные-операции)
  - [Операции с присваиванием и выражения с ними](#операции-с-присваиванием-и-выражения-с-ними)
- [Преобразование типов](#преобразование-типов)
  - [Расширение целочисленных типов](#расширение-целочисленных-типов)
  - [Преобразование целочисленных типов](#преобразование-целочисленных-типов)
  - [Преобразование целых чисел в вещественные и наоборот](#преобразование-целых-чисел-в-вещественные-и-наоборот)
  - [Вещественные типы](#вещественные-типы)
  - [Арифметические преобразования](#арифметические-преобразования)
  - [Явное приведение типов](#явное-приведение-типов)
- [Условные выражения и тернарный оператор](#условные-выражения-и-тернарный-оператор)
- [Приоритет и порядок вычисления](#приоритет-и-порядок-вычисления)
- [Управляющие конструкции](#управляющие-конструкции)
  - [Операторы и блоки](#операторы-и-блоки)
  - [Оператора `if`, `if-else`, `else-if`](#оператора-if-if-else-else-if)
  - [Оператор `switch`](#оператор-switch)
  - [Цикл `while`](#цикл-while)
  - [Цикл `for`](#цикл-for)
  - [Цикл `do-while`](#цикл-do-while)
  - [Операторы `break` и `continue`](#операторы-break-и-continue)
  - [Оператор `goto` и метки](#оператор-goto-и-метки)
- [Функции](#функции)
  - [Определение функции](#определение-функции)
  - [Функции, возвращающие нецелые значения](#функции-возвращающие-нецелые-значения)
  - [Внешние переменные](#внешние-переменные)
    - [Различие между объявлением и определением внешней переменной](#различие-между-объявлением-и-определением-внешней-переменной)
  - [Область видимости](#область-видимости)
- [Заголовочные файлы](#заголовочные-файлы)
- [Статические переменные](#статические-переменные)
- [Регистровые переменные](#регистровые-переменные)
- [Блочная структура](#блочная-структура)
- [Рекурсия](#рекурсия)


# Установка компилятора для C

Для установки компилятора для C на систему Windows можно воспользоваться [MSYS2](https://www.msys2.org/).

# Hello, World и процесс запуска программы

Файл с программой [`hello_world.c`](../src/c_programming/hello_world.c):

```c
#include <stdio.h>

int main()
{
  printf("hello, world");
  return 0;
}
```

Компилируем программу с помощью следующей команды: `cc hello_world.c`

Если во время компиляции не было ошибок, то после этого в системе Windows создается файл с расширением `.exe` - `a.exe`.

Далее запускаем этот файл: `.\a.exe`.

В консоли мы должны увидеть следующий текст:

```
hello, world
```

Если программа содержит несколько файлов, то они перечисляются друг за другом после `cc`:

```
cc main.c getline.c strindex.c
```

Эта команда помещает объектный код, полученный в результате компиляции в файлы `main.o`, `getline.o`, `strindex.o`, а затем компонует их все в выполняемую программу `a.exe` (windows) или `a.out` (unix).

Если во время компиляции в одном из файлов (например, `main.c`) встретится синтаксическая ошибка, то его можно будет перекомпилировать с помощью следующей команды:

```
cc main.c getline.o strindex.o
```

# Имена переменных

- Переменные могут состоять из букв и цифр
- Начинаться имя переменной может только с буквы
- Знак подчеркивания `_` считается буквой и часто используется для улучшения читаемости длинных имен
- Не следует начинать имя переменной с подчеркивания `_`, так как такие имена часто используют библиотеки
- Буквы в верхнем и нижнем регистре отличаются (`x` и `X` - это разные имена)
- Традиционно имена переменных записывают строчными буквами, а имена констант - прописными
- Ключевые слова зарезервированы и не могут быть использованы как имена переменных (например, `if`, `else` и т.д.)
- Разумно выбирать имена переменных так, чтобы они описывали назначение самих переменных
- Есть тенденция использовать короткие имена для локальных переменных, счетчиков, циклов и т.д. и имена подлиннее для глобальных переменных

# Типы данных и их размеры

| Тип данных | Описание                                                 | Занимаемая память                                                                   | Диапазон значений (зависит от системы)                                       |
| ---------- | -------------------------------------------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| `char`     | Содержит один символ из локального набора                | 8 бит                                                                               | от -128 до 127                                                               |
| `int`      | Целое число                                              | Обычно имеет типовой размер для целых чисел в данной системе, обычно 16 или 32 бита | от –32768 до 32767 (16 бит) или от −2.147.483.648 до 2.147.483.647 (32 бита) |
| `float`    | Вещественное число одинарной точности с плавающей точкой | 32 бита                                                                             | от +/- 3.4E-38 до 3.4E+38                                                    |
| `double`   | Вещественное число двойной точности с плавающей точкой   | 64 бита                                                                             | от +/- 1.7E-308 до 1.7E+308                                                  |
| `void`     | Тип без значения                                         | -                                                                                   | -                                                                            |

**Модификаторы** `short` и `long` применяются только к целым числам (введены для разграничения длины двух типо целых чисел для практических потребностей):

| Тип данных + Модификатор | Псевдоним                                                         | Занимаемая память | Диапазон значений (зависит от системы)                      |
| ------------------------ | ----------------------------------------------------------------- | ----------------- | ----------------------------------------------------------- |
| `long`                   | `long int` или `signed long int` или `signed long`                | 32 бита           | от -2.147.483.648 до 2.147.483.647                          |
| `short`                  | `short int` или `signed short int` или `signed short`             | 16 бит            | от –32768 до 32767                                          |
| `long long`              | `long long int` или `signed long long int` или `signed long long` | 64 бита           | от -9.223.372.036.854.775.807 до +9.223.372.036.854.775.807 |

**Модификаторы** `signed` ("со знаком") или `unsigned` ("без знака") могут применяться к типу `char` или целому числу. Числа типа `unsigned` всегда неотрицательны, а длина диапазона их значений равна степени двойки 2^n, где n - количество битов в машинном представлении:

| Тип данных + Модификатор | Псевдоним                                                     | Занимаемая память  | Диапазон значений (зависит от системы)                                       |
| ------------------------ | ------------------------------------------------------------- | ------------------ | ---------------------------------------------------------------------------- |
| `unsigned char`          | -                                                             | 8 бит              | от 0 до 255                                                                  |
| `signed char`            | `char`                                                        | 8 бит              | от -128 до 127                                                               |
| `unsigned int`           | `unsigned`                                                    | 16 бит или 32 бита | от 0 до 65535 (для 16 бит), либо от 0 до 4.294.967.295 (для 32 бит)          |
| `signed int`             | `signed` или `int`                                            | 16 бит или 32 бита | от –32768 до 32767 (16 бит) или от −2.147.483.648 до 2.147.483.647 (32 бита) |
| `unsigned long`          | `unsigned long int`                                           | 32 бита            | от 0 до 4.294.967.295                                                        |
| `signed long`            | `long` или `long int` или `signed long int` или `signed long` | 32 бита            | от -2.147.483.648 до 2.147.483.647                                           |
| `unsigned long long`     | `unsigned long long int`                                      | 64 бита            | от 0 до 18.446.744.073.709.551.615                                           |
| `signed long long`       | `long long int` или `signed long long int` или `long long`    | 64 бита            | от -9.223.372.036.854.775.807 до +9.223.372.036.854.775.807                  |
| `unsigned short`         | `unsigned short int`                                          | 16 бит             | от 0 до 65535                                                                |
| `signed short`           | `short int` или `signed short int` или `short`                | 16 бит             | от –32768 до 32767                                                           |

**Модификатор** `long` для типа `double` - обозначает число с плавающей точкой повышенной точности:

| Тип данных + Модификатор | Занимаемая память | Диапазон значений (зависит от системы) |
| ------------------------ | ----------------- | -------------------------------------- |
| `long double`            | -                 | 80 бит                                 | от +/- 3.4E-4932 до 1.1E+4932 |

## Суффиксы для типов данных

Любое десятичное число рассматривается по умолчанию как значение типов `int`/`long int`/`long long int` (в зависимости от размера) и при присвоении переменным другим типов будет выполняться преобразование. Чтобы указать, что число явным образом представляет определенный тип, к числу добавляется определенный суффикс:

| Тип                                                            | Суффикс         | Например              |
| -------------------------------------------------------------- | --------------- | --------------------- |
| `unsigned int`, `unsigned long int` и `unsigned long long int` | `u` или `U`     | `123u` или `123U`     |
| `unsigned long int` и `unsigned long long int`                 | `ul` или `UL`   | `123ul` или `123UL`   |
| `long long int`                                                | `ll` или `LL`   | `123ll` или `123LL`   |
| `unsigned long long int`                                       | `ull` или `ULL` | `123ull` или `123ULL` |
| `float`                                                        | `f`             | `3.14f`               |
| `long double`                                                  | `l`             | `3.14l`               |
| `double`                                                       | `f` или `lf`    | `3.14f` или `3.14lf`  |

## Спецификаторы для вывода чисел в консоль в функции `printf`

> Переменная `num` в примере соответствует типу из колонки 1.

| Тип                                                                               | Спецификатор                          | Пример                 |
| --------------------------------------------------------------------------------- | ------------------------------------- | ---------------------- |
| `char`                                                                            | `%d` (числовое представление символа) | `printf("%d", num);`   |
| `char`                                                                            | `%c` (вывод символа)                  | `printf("%c", num);`   |
| `unsigned short` или `unsigned short int`                                         | `%hu`                                 | `printf("%hu", num);`  |
| `short` или `short int` или `signed short` или `signed short int` или `int`       | `%d`                                  | `printf("%d", num);`   |
| `long` или `long int` или `signed long` или `signed long int`                     | `%ld`                                 | `printf("%ld", num);`  |
| `unsigned long` или `unsigned long int`                                           | `%lu`                                 | `printf("%lu", num);`  |
| `long long` или `long long int` или `signed long long` или `signed long long int` | `%lld`                                | `printf("%lld", num);` |
| `unsigned long long` или `unsigned long long int`                                 | `%llu`                                | `printf("%llu", num);` |
| `double` или `float`                                                              | `%f`                                  | `printf("%f", num);`   |
| `long double`                                                                     | `%Lf`                                 | `printf("%Lf", num);`  |

## Представление числа в различных системах

| Символы      | Описание                                                                       | Пример                                 |
| ------------ | ------------------------------------------------------------------------------ | -------------------------------------- |
| `0b`         | Двоичное представление числа (набор из 0 и 1)                                  | `0b1011` - число 11 в 10-ичной системе |
| `0`          | Восьмеричная система счисления (набор из цифр от 0 до 7)                       | `013` - число 11                       |
| -            | Десятичная система счисления (набор из цифр от 0 до 9)                         | `11` - число 11                        |
| `0x`или `0X` | Шестнадцатеричная система счисления (набор из цифр от 0 до 9 и бква от A до F) | `0xB` или `0XB` - число 11             |

## Определение размера типов данных

```c
#include <stdio.h>

int main()
{
  int number = 2;
  printf("sizeof(number) = %d \n", sizeof(number)); // Вывод: sizeof(number) = 4 (размер в байтах)
  return 0;
}
```

# Управляющие последовательности

| Управляющая последовательность | Описание                  |
| ------------------------------ | ------------------------- |
| `\a`                           | Подача звукового сигнала  |
| `\b`                           | Возврат назад и затирание |
| `\f`                           | Прогон страницы           |
| `\n`                           | Конец строки              |
| `\r`                           | Возврат каретки           |
| `\t`                           | Горизонтальная табуляция  |
| `\v`                           | Вертикальная табуляция    |
| `\\`                           | Обратная косая черта      |
| `\?`                           | Вопросительный знак       |
| `\'`                           | Одинарная кавычка         |
| `\"`                           | Двойная кавычка           |

Представление символов с помощью управляющей последовательности:

| Представление | Описание                                                 | Пример                                  |
| ------------- | -------------------------------------------------------- | --------------------------------------- |
| `\ooo`        | Представление символа с помощью восмеричного числа       | `\013` - вертикальная табуляция в ASCII |
| `\xhh`        | Представление символа с помощью шестнадцатеричного числа | `\xb` - вертикальная табуляция в ASCII  |

# Константы

**Константа** — это значение, которое впоследствии в процессе программы не может быть изменено.

| Константа                                                             | Описание                                                                                                | Примеры                                                       |
| --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| **Целочисленная константы**                                           | Константы, которые имеют целочисленный тип                                                              | `123`, `123L`, `0XFUL`                                        |
| **Символьная константы**                                              | Целое число в форме одного символа в кавычках                                                           | `'x'`, `'X'`, `'\013'`, `'\xb'`                               |
| **Вещественная константы**                                            | Константы, которые имеют вещественный тип                                                               | `123.321`, `1.2345E-20l`                                      |
| **Константное выражение**                                             | Выражение, содержащее только константы (могут вычисляться в ходе компиляции, а не выполнения программы) | `#define MAXLINE 1000`                                        |
| **Строковая константа**, **строковый литерал** или просто **литерал** | Последовательность из нескольких (в частном случае ни одного) символов, заключенных в двойные кавычки   | `"I am a string"`, `""`                                       |
| **Константы перечислимого типа**                                      | Перечислимы тип определяется списком целочисленных символических констант                               | `enum boolean { NO, YES }` (первая константа - 0, вторая - 1) |

## Строковые константы

Кавычки не являются часть строки, а только ограничивают ее. Все управляющие последовательность, которые можно включить в символьные константы, допускаются в строковых, например, `\"`. Строковые константы можно сцеплять (выполнять конкатенацию) в процессе компиляции. Следующие 2 строки являются эквивалентными:

```
"hello, " "world"
"hello, world"
```

Этой возможность можно пользоваться, когда нужно распространить длинные строковые константы на несколько строк исходного кода.

Во внутреннем представлении строки в конце присутствует нулевой символ `'\0'`, так что физический объем памяти для хранения строки превышает количество символов, записанных между кавычками, на единицу.

Стандартная библиотечная `<string.h>` содержит функцию `strlen(s)`, которая возвращает количество символов в строке, переданной ей в качестве аргумента, не считая завершающего `'\0'`. 

## Константы перечислимого типа

**Перечисления** - это удобный способ ассоциировать значения констант с символическими именами с тем преимущество перед `#define`, что значения могут генерироваться автоматически.

```c
enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t' };
enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC }; // FEB = 2, MAR = 3, ...
```

# Объявление и инициализация

В **объявлении** указываются тип и список из одной или нескольких переменных:

```c
int lower, upper, step;
char c, line[1000];
int stop;
int go;
```

Переменную можно **инициализировать** прямо в объявлениях (т.е. присвоить значение во время создания переменной):

```c
#define MAXLINE 1000

// инициализация в объявлениях
char esc = '\\';
int i = 0;
int limit = MAXLINE + 1;
float eps = 1.0e-05;
```

- При отсутствии явной инициализации внешние и статические переменные гарантировано инициализируются нулями, а автоматические и регистровые получают неопределенные начальные значения ("мусор"). 
- Инициализирующие выражения для внешних и статических переменных должны быть константыми; инициализация выполняется один раз, фактически до начала выполнения программы. А для автоматических и регистровых переменных инициализация выполняется каждый раз при входе в соответствующий блок.
- Инициализирующие выражения для автоматических и регистровых переменных не обязано быть константым - оно может содержать любые значения, определенные ранее, даже вызовы функций

Для инициализации массива необходимо поставить после его объявления и знака равенства список инициализирующих значений, разделенных запятыми, в фигурных скобках:

```c
// без указания величины массива, компилятор вычислит его сам
int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

// если указать меньше значений, чем размер массива, то недостающие значения будут заменены нулями
int months[4] = { 2, 4 }; // 3 и 4 переменные будут нули

// если значений больше, чем размер массива, то это вызовет ошибку
int years[4] = { 1992, 1993, 1994, 1995, 1996 }; // будет ошибка
```

**Не существует способа задать повторение инициализирующих значений в сокращенном виде, а также инициализировать какой-нибудь средний элемент массива, не инициализировав все предыдущие.**

**Массивы символов** - особый случай; для их инициализации можно использовать строку вместо фигурных скобок и запятых:

```c
char pattern[] = "ould";

// запись выше эквивалентна следующей записи
char pattern[] = { 'o', 'u', 'l', 'd', '\0' }; // \0 - завершающий символ
```

## Модификатор `const`

К объявлению любой переменной можно добавить модификатор `const`, чтобы значение этой переменной впоследствии не менялось. В случае массива этот модификатор запрещает изменение любого из элементов.

```c
const double e = 2.718;
const char msg[] = "warning: ";
```

Декларация `const` может употребляться с аргументами-массивами, указывая тем самым, что функция не изменяет передавайемый ей массив:

```c
int strlen(const char[]);
```

Если предпринимается попытка изменить переменную, объявленную с модификатором `const`, ее результат будет зависеть от реализации языка.

# Операции
## Арифметические операции

| Операция | Описание                                                                               | Пример               |
| -------- | -------------------------------------------------------------------------------------- | -------------------- |
| `+`      | Сложение                                                                               | `4 + 5`              |
| `-`      | Вычитание                                                                              | `4 - 5`              |
| `*`      | Умножение                                                                              | `4 * 5`              |
| `/`      | Целочисленное деление (оба операнда - целые числа, остаток от деления отбрасывается)   | `9 / 4`              |
| `/`      | Деление (оба (или один) операнда - вещественные числа, результат - вещественное число) | `9.0 / 4`, `9 / 4.0` |
| `%`      | Остаток от деления (только для целых чисел)                                            | `9 % 4`              |

## Операции отношения и логические операции

**Операции отношения** (тип операндов должен быть одинаковым):

| Операция | Описание                                                                                        | Пример              |
| -------- | ----------------------------------------------------------------------------------------------- | ------------------- |
| `>`      | Больше (вернет 1, если левый операнд больше правого, и 0 в обратном случае)                     | `4 > 5`, `10 > 2    |
| `>=`     | Больше или равно (вернет 1, если левый операнд больше или равен правому, и 0 в обратном случае) | `4 >= 4`, `10 >= 2` |
| `<`      | Меньше (вернет 1, если левый операнд меньше правого, и 0 в обратном случае)                     | `4 < 5`, `10 < 2`   |
| `<=`     | Меньше или равно (вернет 1, если левый операнд меньше или равен правому, и 0 в обратном случае) | `4 <= 5`, `10 <= 2` |
| `==`     | Равенство (вернет 1, если оба операнда равны, и 0 в обратном случае)                            | `4 == 5`, `4 == 4`  |
| `!=`     | Неравенство (вернет 1, если оба операнда не равны, и 0 в обратном случае)                       | `4 != 5`, `4 != 4`  |

**Логические операции**:

| Операция | Описание                                                                                 | Пример               |
| -------- | ---------------------------------------------------------------------------------------- | -------------------- |
| `&&`     | Операция `И` (вернет 1, если оба операнда равны 1, и 0 в обратном случае)                | `4 == 5 && 2 == 1`   |
| `\|\|`   | Операция `ИЛИ` (вернет 1, если хотя бы один операнд равны 1, и 0 в обратном случае)      | `4 == 4 \|\| 2 == 4` |
| `!`      | Операция `НЕ` (вернет значение, обратное операнду: если было 1, то станет 0, и наоборот) | `!(4 == 4)`          |

Пример использования (ввод символов из консоли в массив символов):

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
  int i, lim = 100;
  char c, s[lim];
  for (i = 0; i < lim - 1 && (c = getchar()) != '\n' && c != EOF; ++i) {
    s[i] = c;
  }
  return 0;
}
```

## Операции инкрементирования и декрементирования

**Постфиксная** инкрементация (`i++`) - добавляет единицу к операнду **после того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", i++ + j); // Вывод: 10. Сначала i + j, затем i + 1 (от инкрементации)
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 11
  return 0;
}
```

**Префиксная** инкрементация (`++i`) - добавляет единицу к операнду **до того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", ++i + j); // Вывод: 11. Сначала i + 1 (от инкрементации), затем i + j
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 11
  return 0;
}
```

**Постфиксная** декрементация (`i--`) - вычитает единицу от операнда **после того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", i-- + j); // Вывод: 10. Сначала i + j, затем i - 1 (от инкрементации)
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 9
  return 0;
}
```

**Префиксная** декрементация (`--i`) - вычитает единицу от операнда **до того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", --i + j); // Вывод: 9. Сначала i - 1 (от инкрементации), затем i + j
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 9
  return 0;
}
```

## Поразрядные операции

| Операция | Описание                                                                                                                                                                        | Пример                                                                                                                                       |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `&`      | Порязрадное `И` (часто используется для обнуления некоторого набора битов)                                                                                                      | `n = n & 0177` - обнуляет все биты переменной `n`, кроме младших семи                                                                        |
| `\|`     | Поразрядное включающее `ИЛИ` (часто используется для того, чтобы сделать отдельные биты единицами)                                                                              | `x = x \| SET_ON` - делает единицами все биты, которые равны 1 в константе `SET_ON`                                                          |
| `^`      | Поразрядное исключающее `ИЛИ` (помещает единицу в позиции, где в операндах состоят различные биты, и нуль в те позиции, в которых биты операндов совпадают)                     | `x = 123 ^ 521`                                                                                                                              |
| `<<`     | Сдвиг влево (выполняет сдвиг своего левого операнда влево на количество разрядов (битовых позиций), заданных правым операндом, который обязательно должен быть положительным)   | `x << 2` - сдвигает значение `x` влево на две разрядные позиции, заполняя вакантные биты нулями (в итоге это то же самое, что и `x = x * 4`) |
| `>>`     | Сдвиг вправо (выполняет сдвиг своего левого операнда вправо на количество разрядов (битовых позиций), заданных правым операндом, который обязательно должен быть положительным) | `x >> 2`                                                                                                                                     |
| `~`      | Одноместное поразрядное дополнение до единицы, т.е. преобразование каждого единичного бита в нулевой и наоборот                                                                 | `x = ~077`                                                                                                                                   |

**Сдвиг вправо** числа типа `unsigned` всегда заполняет освободившиеся биты нулями. Сдвиг вправо числа со знаком в некоторых системах приводит к заполнению этих битов значением знакового бита ("арифметический сдвиг"), а в других - нулями ("логический сдвиг").

## Операции с присваиванием и выражения с ними

| Операция     | Операция с присваиванием |
| ------------ | ------------------------ |
| `i = i + 2`  | `i += 2`                 |
| `i = i - 2`  | `i -= 2`                 |
| `i = i * 2`  | `i *= 2`                 |
| `i = i / 2`  | `i /= 2`                 |
| `i = i % 2`  | `i %= 2`                 |
| `i = i << 2` | `i <<= 2`                |
| `i = i >> 2` | `i >>= 2`                |
| `i = i & 2`  | `i &= 2`                 |
| `i = i ^ 2`  | `i ^= 2`                 |
| `i = i \| 2` | `i \|= 2`                |

# Преобразование типов

Правила преобразования типов:

- Единственное корректное автоматическое преобразование типов - это то, в котором более "узкий" тип преобразуется в более "широкий" без потери информации, например, при сложении числа типа `int` с числом типа `float` (автоматически преобразуется во `float`). Преобразование происходит до выполнения операции с этими числами.
- Выражения, которые не имеют смысла, запрещены. Например, использование типа `float` в качестве индексов массива
- Выражения, в которых может произойти частичная потеря информации, могут привести к выдаче предупреждения, но не запрещены. Например, помещение числа длинного типа в переменную более короткого типа или вещественного числа в целую переменную
- Переменные типа `char` - это короткие целые числа, поэтому их можно свободно использовать в арифметических выражениях. Например, можно преобразовывать символьную строку цифр в ее смысловой эквивалент - целое число (функция [atoi](https://en.cppreference.com/w/c/string/byte/atoi)). Преобразование символов в целые числа зависит от конкретной системы.

## Расширение целочисленных типов

Если `int` позволяет представить все значения исходного типа операнда, то операнд приводится к `int`, в противном случае - к `unsigned int`. Эта процедура называется **расширение целочисленного типа** (integral promotion)

## Преобразование целочисленных типов

Чтобы привести целое число к некоторому заданному типу без знака, ищется конгруэнтное (т.е. имеющее то же двоичное представление) наименьшее неотрицательное значение, а затем получается остаток от деления его на `UMAX + 1`, где `UMAX` - наибольшее число в данном типе без знака. При использовании двоичного представления в дополнительном коде ("дополнения к двойке") для этого либо отбрасываются лишние левые разряды, если двоичное представление беззнакового типа уступает в длине исходному типу, либо недостающие старшие разряды заполняются нулями (в числах без знака) или значением знака (в числах со знаком), если тип без знака шире исходного.

В результате приведения целого числа к знаковому типу его значение не изменяется, если оно представимо в этом новом типе; в противном случае результат зависит от реализации.

## Преобразование целых чисел в вещественные и наоборот

При преобразовании из вещественного типа в целочисленный дробная часть числа отбрасывается; если полученное при этом значение нельзя представить величиной заданного целочисленного типа, то результат не определен. В частности, не определен результат преобразования отрицательных чисел с плавающей точкой в целые числа без знака.

Если число преобразуется из целого в вещественное и находится в допустимом диапазоне, но представляется в новом типе недостаточно точно, то результатом будет большее или меньшее ближайшее значение нового типа. Если результат выходит за границы диапазона допустимых значений, результат не определен.

## Вещественные типы

При преобразовании из вещественного типа меньшей точности к типу большей точности число не изменяется. Если же преобразование выполняется от большей точности к меньшей и число остается в допустимых пределах нового типа, то результатом будет большее или меньшее ближайшее значение нового типа. Если результат выходит за границы допустимого диапазона, результат не определен.

## Арифметические преобразования

Во многих операциях преобразование типов операндов и определение типа результата следуют одной и той же схеме. В результате операнды приводятся к некоторому общему типу, который также является и типом результата. Эта схема включает в себя **обычные арифметические преобразования**:

- Если какой-либо из операндов имеет тип `long double`, то и другой приводится к `long double`
- Иначе, если какой-либо из операндов имеет тип `double`, то и другой приводится к `double`
- Иначе, если какой-либо из операндов имеет тип `float`, то и другой приводится к `float`
- Иначе, если один из операндов имеет тип `unsigned long int`, то и другой приводится к `unsigned long int`
- Иначе, если один из операндов имеет тип `long int`, а другой `unsigned int`, то результат зависит от того, представляет ли `long int` все значения `unsigned int`:
  - Если да, то операнд типа `unsigned int` приводится к `long int`
  - Если нет, то оба операнда преобразуются в `unsigned long int`
- Иначе, если один из операндов имеет тип `long int`, то и другой приводится к `long int`
- Иначе, если один из операндов имеет тип `unsigned int`, то и другой приводится к `unsigned int`
- Иначе, оба операнда имеют тип `int`

## Явное приведение типов

```
(имя-тип) выражение
```

Например:

```c
int n = 10;
sqrt((double) n);
```

# Условные выражения и тернарный оператор

```c
#include <stdio.h>

int main()
{
  int a = 2, b = 3, z;
  // Условное выражение
  if (a > b) // Если a больше b, то выполняем следующий блок
  {
    z = a;
  }
  else // В противном случае выполняем этот блок
  {
    z = b;
  }
  return 0;
}
```

Это условное выражение можно записать с помощью трехместной операции `?:` (**тернарный оператор**):

```c
#include <stdio.h>

int main()
{
  int a = 2, b = 3;
  // Условное выражение с трехместной операцией 
  int z = (a > b) ? a : b;
  return 0;
}
```

# Приоритет и порядок вычисления

> В самом верху таблицы операции имеют высший приоритет, а в самом низу таблицу самый низкий приоритет (т.е. выполняются в последнюю очередь).

| Операции                                                                                                                                                                                         | Ассоциирование |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------- |
| `()` (вызов функции), `[]`, `->` (обращение к элементам структур), `.` (обращение к элементам структур)                                                                                          | Слева направо  |
| `!`, `~`, `++`, `--`, `+` (унарный плюс), `-` (унарный минус), `*` (ссылка по указателю), `&` (получение адреса объекта), `(тип)` (преобразование к типу), `sizeof` (вычисление размера объекта) | Справа налево  |
| `*`, `/`, `%`                                                                                                                                                                                    | Слева направо  |
| `+`, `-`                                                                                                                                                                                         | Слева направо  |
| `<<`, `>>`                                                                                                                                                                                       | Слева направо  |
| `<`, `<=`, `>`, `>=`                                                                                                                                                                             | Слева направо  |
| `==`, `!=`                                                                                                                                                                                       | Слева направо  |
| `&`                                                                                                                                                                                              | Слева направо  |
| `^`                                                                                                                                                                                              | Слева направо  |
| `\|`                                                                                                                                                                                             | Слева направо  |
| `&&`                                                                                                                                                                                             | Слева направо  |
| `\|\|`                                                                                                                                                                                           | Слева направо  |
| `?:` (тернарный оператор)                                                                                                                                                                        | Справа налево  |
| `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `\|=`, `<<=`, `>>=`                                                                                                                               | Справа налево  |
| `,` (оператор запятая)                                                                                                                                                                           | Слева направо  |

# Управляющие конструкции
## Операторы и блоки

Если в конце выражения стоит `;`, то оно становится **оператором**:

```c
x = 0;
i++;
printf(...);
```

Фигурные скобки `{}` служат для группировки объявлений и операторов в **составные операторы** или **блоки**, синтаксически эквивалентные одному операторы. Например, фигурные скобки, окружающий тело функции. **После правой скобки**, закрывающей блок, **точка с запятой не ставится**.

## Оператора `if`, `if-else`, `else-if`

- `if`:

```c
#include <stdio.h>

int main()
{
  int a = 2, b = 3, z;
  // Оператор if
  if (a > b) // Если a больше b, то выполняем следующий блок
  {
    z = a;
  }
  return 0;
}
```

- `if-else`:

```c
#include <stdio.h>

int main()
{
  int a = 2, b = 3, z;
  // Оператор if
  if (a > b) // Если a больше b, то выполняем следующий блок
  {
    z = a;
  }
  else // Алтернативный блок, если условие не выполнилось (else - опциональный элемент)
  {
    z = b;
  }
  return 0;
}
```

- `else-if`:

```c
#include <stdio.h>

int main()
{
  int a = 2, b = 3, z;
  // Оператор if
  if (a > b) // Основной блок проверки (в цепочке if-else-if мождет быть только 1 такой блок)
  {
    z = a;
  }
  else if (a == b) // Дополнительный блок проверки (может быть сколько угодно)
  {
    z = a + b;
  }
  else // Алтернативный блок, если все условия не выполнились
       // (else - опциональный элемент, может быть только 1 в цепочке if-else-if)
  {
    z = b;
  }
  return 0;
}
```

## Оператор `switch`

Оператор `switch` используется для выбора одного или нескольких вариантов действий в зависимости от того, с какой из набора целочисленных **констант** совпадает значение некоторого выражения.

```c
#include <stdio.h>

int main()
{
  int a = 5;
  switch (a) // принимает выражение
  {
    // если выражение соответствует значению в case, то используется блок из case
    case 1: 
    case 2: // если в блоке нет break, то "проваливаемся" в следующий case
    case 3:
      printf("no numbers"); // оператор в блоке case
      break; // выход из switch
    case 5:
      printf("a = %d", a);
      break;
    default: // блок "по умолчанию" (опциональный), если не выполнился ни один case
      printf("default");
      break;
  }
  return 0;
}
```

Аналог через `if-else-if`:

```c
#include <stdio.h>

int main()
{
  int a = 5;
  if (a == 1 || a == 2 || a == 3)
  {
    printf("no numbers");
  }
  else if (a == 5)
  {
    printf("a = %d", a);
  }
  else
  {
    printf("default");
  }
  return 0;
}
```

## Цикл `while`

Цикл `while` выполняется до тех пор, пока выражение внутри скобок равно `1`:

```c
#include <stdio.h>

int main()
{
  int a = 5;
  
  // Выводим цифры от 5 до 1
  while (a != 0)
  {
    printf("%d\n", a--);
  }
  return 0;
}
```

## Цикл `for`

Цикл `for` выполняется до тех пор, пока выполняется логической выражения (*выражение2*) и имеет следующее устройство (все выражения внутри цикла являются опциональными):

```
for (выражение1; выражение2; выражение3)
{
  // блок с операторами
}
```

- *выражение1* - используется для инициализации переменных, или использовании выражений
- *выражение2* - выражение отношения или логической выражение, если оно равно `1`, то цикл продолжает выполняться
- *выражение3* - используется после прохождения цикла

Цикл `for` следуте предпочесть тогда, когда есть простая инициализация и инкрементирование переменных цикла, поскольку все управляющие элементы цикла в это случае удобно сгруппироования в его заголовке.

Примеры:

- Бесконечный цикл (нет условия выхода):

```c
for (;;) {}
```

- Цикл со всеми выражениями:

```c
for (int i = 0; i < 22; i++) {}
```

- Цикл без *выражение1*:

```c
int i = 0;
for (; i < 22; i++) {}
```

- Цикл с *выражение3* внутри блока цикла:

```c
for (int i = 0; i < 22;)
{
  i++;
}
```

- Цикл с *выражение2* внутри блока цикла:

```c
for (int i = 0; ; i++)
{
  if (i < 22) break; // break - оператор выхода из цикла
}
```

**Как работает цикл `for`**:

```c
for (int i = 0; i < 22; i++) {}
```

1. В начале цикла используется *выражение1* - это блок инициализации. Здесь мы инициализируем переменную `i`, которая имеет начальное значение `0`. Дальше этот блок не будет задействован в цикле.
2. Проверяем *выражение2*, если оно равно 1, то выполняем все операторы внутри блока цикла.
3. После того, как блок цикла завершен, переходим к *выражение3*. Здесь мы увеличиваем переменную `i` на единицу и возвращаемся к шагу 2, пока условие в шаге 2 не перестанет выполняться.

## Цикл `do-while`

Конструкция `do-while` проверяет условие в конце, **после** выполнения тела цикла.

Пример (программа выведет цифру `5`, так как проверка будет происходить после тела цикла):

```c
#include <stdio.h>

int main()
{
  int a = 5;

  do
  {
    printf("%d\n", a); // Вывод: 5
  } while (a != 5);
  return 0;
}
```

## Операторы `break` и `continue`

- `break` - вызывает принудительный выходи из циклов `for`, `while` и `do-while` (аналогично выходу из операторы `switch`)

```c
#include <stdio.h>

int main()
{
  for (int i = 0; i < 20; i++)
  {
    if (i == 5) break; // принудительно выходим из цикла, когда i == 5
    printf("%d\n", i); // Вывод: 0 1 2 3 4
  }
  return 0;
}
```

- `continue` - передает управление на следующую итерацию цикла (проход цикла) ближайшего цикла `for`, `while` и `do-while` (нельзя применить к оператору `switch`, но можно применить в `switch`, если он находится в цикле и нужно перейти к следующей итерации). Оператор `continue` часто используется там, где следующая за ним часть цикла слишком длинная и сложная, так что выделение ее отступами в условном операторе ухудшает удобочитаемость.

```c
#include <stdio.h>

int main()
{
  for (int i = 0; i < 7; i++)
  {
    if (i == 5) continue; // пропускаем итеркцию, когда i == 5
    printf("%d\n", i); // Вывод: 0 1 2 3 4 6
  }
  return 0;
}
```

## Оператор `goto` и метки

Оператор `goto` переходит к той метке, которая в нем указана. В большинстве случаев лучше обходится без этого оператора. Наиболее распространенный случай его использования - необходимость прекратить работу управляющей структуры с большим количеством вложений, например, выйти сразу из двух и более вложенных циклов (в данном случае оператор `break` не может быть применим, так как он обеспечивает выход только из внутреннего цикла). Пример:

```c
#include <stdio.h>

int main()
{
  for (int i = 0; i < 7; i++)
  {
    for (int j = 0; j < 7; j++)
    {
      for (int k = 0; k < 7; k++)
      {
        if ((i + j + k) == 2)
        {
          // при выполнении условия мы переходим на метку с именем exitFromCycle
          goto exitFromCycle; 
        }
      }
    }
  }
  exitFromCycle: // метка с именем exitFromCycle
    printf("It's a label = exitFromCycle");
  return 0;
}
```

**Область действия метки** - вся функция.

Код, в котором есть оператор `goto` всегда можно переписать без него, хотя, возможно, придется добавить дополнительную проверку или переменную. Код, основанный на переходах с помощью оператора `goto`, труднее понимать и дорабатывать, чем код без этого оператора.

# Функции
## Определение функции

Определение функции имеет следующую форму:

```
тип-возвращаемого-значения имя-функции(объявления аргументов)
{
  объявления и операторы
}
```

Пример:

```c
dummy() {} // эта функция ничего не делает и ничего не возвращает (функция-заглушка)
```

Чтобы вернуть что-то из функции, используется оператор `return`:

```
return выражение
```

Пример:

```c
int sum(int a, int b)
{
  return a + b;
}
```

## Функции, возвращающие нецелые значения

```c
#include <stdio.h>

int main()
{
  // если функция находится в другом файле или она описана после функции main,
  // то нужно добавить прототип функции, так как по умолчанию функция sum возвращала бы int, а не double
  // если функция не принимает аргументы, то следует указать void
  double sum(double, double);
  double a = 2.2, b = 3.3;
  printf("sum = %lf", sum(a, b));
  return 0;
}

double sum(double a, double b)
{
  return a + b;
}
```

## Внешние переменные

Переменная является внешней, если она определена вне каких бы то ни было функций. Внешние переменные бывают полезны из-за их более широкой области действия и более длительного времени жизни. Например, если двум функциям необходимо иметь общий набор данных, но при это одна из них не вызывает другую, бывает удобнее поместить общие данные во внешние переменные, чем передавать их туда-сюда в виде аргументов.

Пример:

```c
#include <stdio.h>

const int externalVariable = 10; // внешния переменная

int main()
{
  // Прототипы функций
  int minusFromExternalVariable(int);
  int plusToExternalVariable(int);
  printf("minusFromExternalVariable = %d; plusToExternalVariable = %d", minusFromExternalVariable(2), plusToExternalVariable(2));
  return 0;
}

int minusFromExternalVariable(int a)
{
  return externalVariable - a;
}

int plusToExternalVariable(int a)
{
  return externalVariable + a;
}
```

Вывод:

```
minusFromExternalVariable = 8; plusToExternalVariable = 12
```

### Различие между объявлением и определением внешней переменной

Объявление сообщает, что переменная обладает определенными свойствами (в основном типом), а определение выделяет место в памяти для ее хранения.

Если следующие строки фигурирует вне функции, то они являются **определениями** внешних переменных `sp` и `val` (происходит выделение памяти для хранения переменных, также это еще и **объявление**, действительное до конца файла):

```c
int sp;
double val[MAXVAL];
```

С другой стороны, следующие строки дают только **объявление**, которое действует также до конца файла, согласно которому `sp` имеет тип `int`, а `val` является массивом типа `double` (его размер определяется в другом месте). При это память не выделяется и переменные не создаются:

```c
extern int sp;
extern double val[];
```

- Во всех файлах, образующих исходный текст программы, должно быть в общей сложности не больше одного **определения** внешней переменной
- В других файлах могут содержаться **объявления** со словом `extern`, чтобы оттуда можно было к ней обращаться (в файле, содержащем определение переменной, также могут находиться и `extern`-объявление ее же)
- Размер массива обязательно указывается в определении, но необязательно - в объявлении со словом `extern`
- Инициализация внешней переменной выполняется только в определении

Пример:

- файл `file1`:

```c
extern int sp;
extern double val[];

void push(double f) {...}

double pop(void) {...}
```

- файл `file2`:

```c
int sp = 0;
double val[MAXVAL];
```

## Область видимости

**Областью действия (видимости)** имени называется часть программы, в пределах которой можно использовать имя.

- Для автоматической переменной, объявляемой в начале функции, областью видимости является эта функция:

```c
int main()
{
  int a = 2; // по умолчанию переменные, описанные внутри функции, являются автоматическими
  auto int b; // можно подчеркнуть явно с помощью ключевого слова auto
  // так поступают, если хотят показать, что определение переменной не нужно искать вне функции
}
```

- Локальные переменные с одинаковыми именами, объявленные в разных функциях, не имеют никакого отношения друг к другу:

```c
void dummy(void)
{
  int a = 2; // эта переменная отличается от переменной a в функции notDummy
}

void notDummy(void)
{
  int a = 2; // эта переменная отличается от переменной a в функции dummy
}
```

- Параметры функции являются по сути локальными переменными, и для них справедливо предыдущее правило
- Область видимости внешней переменной или функции распространяется от точки, в которой она объявлена до конца компилируемого файла:

```c
void dummy(void) {} // область видимости до конца файла
// -- выше переменную sp не будет видно, так как она объявлена ниже
int sp = 0; // область видимости до конца файла
```

- Если необходимо обратиться к внешней переменной до ее определения или если она определана в другом файле исходного кода, то обязательно нужно вставить объявление с ключевым словом `extern`

# Заголовочные файлы

[**Заголовочный файл**](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B3%D0%BE%D0%BB%D0%BE%D0%B2%D0%BE%D1%87%D0%BD%D1%8B%D0%B9_%D1%84%D0%B0%D0%B9%D0%BB) - файл, содержимое которого автоматически добавляется препроцессором в исходный текст в том месте, где располагается некоторая директива.

**Пример разбивки программы на несколько файлов**

Файл [calculator.c](../src/c_programming/calculator.c) содержит программу калькулятор. Этот калькулятор использует обратную польскую, или бесскобочную. Например, `(1 - 2) * (4 + 5)` мы должны записать в следующем формате: `1 2 - 4 5 + *`.

> Реализация алгоритма: каждый операнд помещается в стек; как только поступает знак операции, из стека извлекается нужное количество операндов (для двухместной операции - два), к ним применяется данная операция, и результат снова помещается в стек. В приведенном примере в стек вначале помещаются 1 и 2, а затем они заменяются из разностью (-1). Затем в стек помещаются 4 и 5, после чего они заменяются их суммой (9). Произведение -1 и 9, т.е. -9, заменяет оба вычисленных операнда в стеке. Как только встретился конец строки входного потока, из стека извлекается и выводится на экран верхнее значение.

Заменим файл с калькулятором на следующую структуру:

- Файл [`main.c`](../src/c_programming/include_directive/main.c) - основной файл запуска программы:

```c
#include <stdio.h>
#include <stdlib.h>
#include "calc.h"
#define MAXOP 100
int main(void)
{
  ...
}
```

- Файл [`calc.h`](../src/c_programming/include_directive/calc.h) - это и есть заголовочный файл, который подключается к файлам кода по мере необходимости:

```c
#define NUMBER '0'
void push(double);
double pop(void);
int getop(char[]);
int getch(void);
void ungetch(int);
```

- Файл [`getop.c`](../src/c_programming/include_directive/getop.c) - реализация функции `getop`:

```c
#include <stdio.h>
#include <ctype.h>
#include "calc.h"
int getop(char[])
{
  ...
}
```

- Файл [`getch.c`](../src/c_programming/include_directive/getch.c) - реализация функций `getch` и `ungetch`:

```c
#include <stdio.h>
#define BUFSIZE 100
char buf[BUFSIZE];
int bufp = 0;
int getch(void)
{
  ...
}
void ungetch(int)
{
  ...
}
```

- Файл [`stack.c`](../src/c_programming/include_directive/stack.c) - реализация стека - функций `pop` и `push`:

```c
#include <stdio.h>
#include "calc.h"
#define MAXVAL 100
int sp = 0;
double val[MAXVAL];
void push(double)
{
  ...
}
double pop(void)
{
  ...
}
```

Чтобы скомпилировать все эти файлы и скомпоновать в один исполняемый файл, можно использовать следующую команду:

```
cc main.c getch.c getop.c stack.c
```

В результате получим исполняемый файл `a.exe` (в windows) или `a.out` (в unix), который мы можем запустить и проверить работоспособность. Пример: вводим `1 2 - 4 5 + *` в результате получим `-9`.

В программах, намного больших по объему, требуется более разветвленная организация и больше заголовочных файлов.

# Статические переменные

Если объявление внешней переменной или функции содержит ключевое слово `static`, то ее область действия ограничивается данным файлом исходного кода - от точки объявления до конца.

Пример:

```c
static char buf[BUFSIZE];
static int bufp = 0;

int getch(void) 
{
  // функция, использующая buf и bufp
}

void ungetch(int c) 
{
  // функция, использующая buf и bufp
}
```

Полный код можно посмотреть в файлах: [`getch.c`](../src/c_programming/include_directive/getch.c) и [`stack.c`](../src/c_programming/include_directive/stack.c).

Также ключевое слово `static` применимо и к функциям:

```c
static void func(void) { ... }
```

Ключевое слово `static` применимо и к внутренним переменным - они являются локальными по отношению к конкретной функции, как и автоматические. Но в отличие от автоматических статические переменные продолжают существовать непрерывно, а не создаются и уничтожаются при вызове и завершении функции. Получается, что внутренние статические переменные являются средством постоянного хранения скрытой информации внутри одной функции:

```c
int getop(char s[])
{
  int i;
  static int c;
  ...
}
```

Полный код можно найти в файле [`getop.c`](../src/c_programming/include_directive/getop.c).

# Регистровые переменные

Объявление с ключевым словом `register` сообщает компилятору, что соответствующая переменная будет интенсивно использоваться программой. Идея заключается в том, чтобы поместить такие (*регистровые*) переменные в регистры процессора и добиться повышения быстродействия и уменьшения объема кода. Впрочем, компилятор имеет право игнорировать эту информаци.

Пример:

```c
register int x;
register char c;
```

Объявление `register` применимо только к автоматическим переменным и к формальным параметрам функций. Пример:

```c
void f(register unsigned m, register long n)
{
  register int i;
  ...
}
```

**Ограничения**:

- В каждой функции только очень неболльшое количество переменных (и только определенных типов) можно сделать регистровыми
- Избыточные или неразрешенные объявления просто игнорируются компилятором
- Не разрешается вычислять адрес регистровой переменной, причем независимо от того, помещена ли она на самом деле в регистр процессора или нет
- Конкретные ограничения на количество и тип регистровых переменных зависят от системы и аппаратного обеспечения

# Блочная структура

Язык C не является блочно-структурным, так как функции нельзя определять внутри других функций. Объявления переменных (в том числе инициализации) могут стоять после левой фигурной скобки, открывающей *любой* составной оператор, а не только после такой, которая открывает тело функции. Переменные, объявленные таким образом, блокируют действие любых переменных с теми же именами, объявленных во внешних блоках, и остаются в силе, пока не встретится соответствующая (закрывающая) правая скобка. Пример:

```c
if (n > 0)
{
  int i; // каждый раз при входе в блок if объявляется новая переменная i
  ...
}
```

Автоматические переменные, в том числе формальные параметры, также преобладают над внешними переменными и функциями с теми же именами, скрывая и блокируя действие их имен. Пример:

```c
int x;
int y;

void f(double x)
{
  double y;
  // внутри функции будут использоваться переменные типа double, а не внешние типа int
}
```

# Рекурсия

**Рекурсия** - это вызов функции самой себя (прямо или косвенно).

Пример рекурсии ([`recursion.c`](../src/c_programming/recursion.c)):

```c
#include <stdio.h>

// printd: вывод числа n десятичными цифрами
void printd(int n)
{
  if (n < 0)
  {
    putchar('-'); // вывод символа в стандартный поток вывода
    n = -n;
  }

  if (n / 10)
  {
    printd(n / 10); // рекурсивный вызов функции
  }

  putchar(n % 10 + '0'); // вывод цифры в стандартный поток вывода
}

int main(void)
{
  printd(-152425); // Вывод: -152425
  return 0;
}
```

Особенности рекурсии:

- Рекурсия может оказаться несовместимой с экономией памяти, поскольку нужно где-то хранить стек обрабатываемых чисел
- Рекурсия не дает выигрыша в быстродействии
- Рекурсивынй код обычно компактнее, и его значительно легче писать и дорабатывать, чем его аналог без рекурсии
- Рекурсия обычно удобна при работе с рекурсивно определенными структурами данных (наподобие деревьев)