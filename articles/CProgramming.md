<h1>Шпаргалка по C</h1>

<h1>Содержание</h1>

- [Установка компилятора для C](#установка-компилятора-для-c)
- [Hello, World и процесс запуска программы](#hello-world-и-процесс-запуска-программы)
- [Переменные](#переменные)
- [Типы данных и их размеры](#типы-данных-и-их-размеры)
  - [Суффиксы для типов данных](#суффиксы-для-типов-данных)
  - [Спецификаторы для вывода чисел в консоль в функции `printf`](#спецификаторы-для-вывода-чисел-в-консоль-в-функции-printf)
  - [Представление числа в различных системах](#представление-числа-в-различных-системах)
  - [Определение размера типов данных](#определение-размера-типов-данных)
- [Управляющие последовательности](#управляющие-последовательности)
- [Константы](#константы)
  - [Строковые константы](#строковые-константы)
  - [Константы перечислимого типа](#константы-перечислимого-типа)
- [Объявления](#объявления)
  - [Модификатор `const`](#модификатор-const)
- [Операции](#операции)
  - [Арифметические операции](#арифметические-операции)
  - [Операции отношения и логические операции](#операции-отношения-и-логические-операции)
  - [Операции инкрементирования и декрементирования](#операции-инкрементирования-и-декрементирования)
  - [Поразрядные операции](#поразрядные-операции)
  - [Операции с присваиванием и выражения с ними](#операции-с-присваиванием-и-выражения-с-ними)
- [Преобразование типов](#преобразование-типов)
  - [Расширение целочисленных типов](#расширение-целочисленных-типов)
  - [Преобразование целочисленных типов](#преобразование-целочисленных-типов)
  - [Преобразование целых чисел в вещественные и наоборот](#преобразование-целых-чисел-в-вещественные-и-наоборот)
  - [Вещественные типы](#вещественные-типы)
  - [Арифметические преобразования](#арифметические-преобразования)
  - [Явное приведение типов](#явное-приведение-типов)
- [Условные выражения](#условные-выражения)
- [Приоритет и порядок вычисления](#приоритет-и-порядок-вычисления)


# Установка компилятора для C

Для установки компилятора для C на систему Windows можно воспользоваться [MSYS2](https://www.msys2.org/).

# Hello, World и процесс запуска программы

Файл с программой [`hello_world.c`](../src/c_programming/hello_world.c):

```c
#include <stdio.h>

int main()
{
  printf("hello, world");
  return 0;
}
```

Компилируем программу с помощью следующей команды: `cc hello_world.c`

Если во время компиляции не было ошибок, то после этого в системе Windows создается файл с расширением `.exe` - `a.exe`.

Далее запускаем этот файл: `.\a.exe`.

В консоли мы должны увидеть следующий текст:

```
hello, world
```

# Переменные

- Переменные могут состоять из букв и цифр
- Начинаться имя переменной может только с буквы
- Знак подчеркивания `_` считается буквой и часто используется для улучшения читаемости длинных имен
- Не следует начинать имя переменной с подчеркивания `_`, так как такие имена часто используют библиотеки
- Буквы в верхнем и нижнем регистре отличаются (`x` и `X` - это разные имена)
- Традиционно имена переменных записывают строчными буквами, а имена констант - прописными
- Ключевые слова зарезервированы и не могут быть использованы как имена переменных (например, `if`, `else` и т.д.)
- Разумно выбирать имена переменных так, чтобы они описывали назначение самих переменных
- Есть тенденция использовать короткие имена для локальных переменных, счетчиков, циклов и т.д. и имена подлиннее для глобальных переменных

# Типы данных и их размеры

| Тип данных | Описание                                                 | Занимаемая память                                                                   | Диапазон значений (зависит от системы)                                       |
| ---------- | -------------------------------------------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| `char`     | Содержит один символ из локального набора                | 8 бит                                                                               | от -128 до 127                                                               |
| `int`      | Целое число                                              | Обычно имеет типовой размер для целых чисел в данной системе, обычно 16 или 32 бита | от –32768 до 32767 (16 бит) или от −2.147.483.648 до 2.147.483.647 (32 бита) |
| `float`    | Вещественное число одинарной точности с плавающей точкой | 32 бита                                                                             | от +/- 3.4E-38 до 3.4E+38                                                    |
| `double`   | Вещественное число двойной точности с плавающей точкой   | 64 бита                                                                             | от +/- 1.7E-308 до 1.7E+308                                                  |
| `void`     | Тип без значения                                         | -                                                                                   | -                                                                            |

**Модификаторы** `short` и `long` применяются только к целым числам (введены для разграничения длины двух типо целых чисел для практических потребностей):

| Тип данных + Модификатор | Псевдоним                                                         | Занимаемая память | Диапазон значений (зависит от системы)                      |
| ------------------------ | ----------------------------------------------------------------- | ----------------- | ----------------------------------------------------------- |
| `long`                   | `long int` или `signed long int` или `signed long`                | 32 бита           | от -2.147.483.648 до 2.147.483.647                          |
| `short`                  | `short int` или `signed short int` или `signed short`             | 16 бит            | от –32768 до 32767                                          |
| `long long`              | `long long int` или `signed long long int` или `signed long long` | 64 бита           | от -9.223.372.036.854.775.807 до +9.223.372.036.854.775.807 |

**Модификаторы** `signed` ("со знаком") или `unsigned` ("без знака") могут применяться к типу `char` или целому числу. Числа типа `unsigned` всегда неотрицательны, а длина диапазона их значений равна степени двойки 2^n, где n - количество битов в машинном представлении:

| Тип данных + Модификатор | Псевдоним                                                     | Занимаемая память  | Диапазон значений (зависит от системы)                                       |
| ------------------------ | ------------------------------------------------------------- | ------------------ | ---------------------------------------------------------------------------- |
| `unsigned char`          | -                                                             | 8 бит              | от 0 до 255                                                                  |
| `signed char`            | `char`                                                        | 8 бит              | от -128 до 127                                                               |
| `unsigned int`           | `unsigned`                                                    | 16 бит или 32 бита | от 0 до 65535 (для 16 бит), либо от 0 до 4.294.967.295 (для 32 бит)          |
| `signed int`             | `signed` или `int`                                            | 16 бит или 32 бита | от –32768 до 32767 (16 бит) или от −2.147.483.648 до 2.147.483.647 (32 бита) |
| `unsigned long`          | `unsigned long int`                                           | 32 бита            | от 0 до 4.294.967.295                                                        |
| `signed long`            | `long` или `long int` или `signed long int` или `signed long` | 32 бита            | от -2.147.483.648 до 2.147.483.647                                           |
| `unsigned long long`     | `unsigned long long int`                                      | 64 бита            | от 0 до 18.446.744.073.709.551.615                                           |
| `signed long long`       | `long long int` или `signed long long int` или `long long`    | 64 бита            | от -9.223.372.036.854.775.807 до +9.223.372.036.854.775.807                  |
| `unsigned short`         | `unsigned short int`                                          | 16 бит             | от 0 до 65535                                                                |
| `signed short`           | `short int` или `signed short int` или `short`                | 16 бит             | от –32768 до 32767                                                           |

**Модификатор** `long` для типа `double` - обозначает число с плавающей точкой повышенной точности:

| Тип данных + Модификатор | Занимаемая память | Диапазон значений (зависит от системы) |
| ------------------------ | ----------------- | -------------------------------------- |
| `long double`            | -                 | 80 бит                                 | от +/- 3.4E-4932 до 1.1E+4932 |

## Суффиксы для типов данных

Любое десятичное число рассматривается по умолчанию как значение типов `int`/`long int`/`long long int` (в зависимости от размера) и при присвоении переменным другим типов будет выполняться преобразование. Чтобы указать, что число явным образом представляет определенный тип, к числу добавляется определенный суффикс:

| Тип                                                            | Суффикс         | Например              |
| -------------------------------------------------------------- | --------------- | --------------------- |
| `unsigned int`, `unsigned long int` и `unsigned long long int` | `u` или `U`     | `123u` или `123U`     |
| `unsigned long int` и `unsigned long long int`                 | `ul` или `UL`   | `123ul` или `123UL`   |
| `long long int`                                                | `ll` или `LL`   | `123ll` или `123LL`   |
| `unsigned long long int`                                       | `ull` или `ULL` | `123ull` или `123ULL` |
| `float`                                                        | `f`             | `3.14f`               |
| `long double`                                                  | `l`             | `3.14l`               |
| `double`                                                       | `f` или `lf`    | `3.14f` или `3.14lf`  |

## Спецификаторы для вывода чисел в консоль в функции `printf`

> Переменная `num` в примере соответствует типу из колонки 1.

| Тип                                                                               | Спецификатор                          | Пример                 |
| --------------------------------------------------------------------------------- | ------------------------------------- | ---------------------- |
| `char`                                                                            | `%d` (числовое представление символа) | `printf("%d", num);`   |
| `char`                                                                            | `%c` (вывод символа)                  | `printf("%c", num);`   |
| `unsigned short` или `unsigned short int`                                         | `%hu`                                 | `printf("%hu", num);`  |
| `short` или `short int` или `signed short` или `signed short int` или `int`       | `%d`                                  | `printf("%d", num);`   |
| `long` или `long int` или `signed long` или `signed long int`                     | `%ld`                                 | `printf("%ld", num);`  |
| `unsigned long` или `unsigned long int`                                           | `%lu`                                 | `printf("%lu", num);`  |
| `long long` или `long long int` или `signed long long` или `signed long long int` | `%lld`                                | `printf("%lld", num);` |
| `unsigned long long` или `unsigned long long int`                                 | `%llu`                                | `printf("%llu", num);` |
| `double` или `float`                                                              | `%f`                                  | `printf("%f", num);`   |
| `long double`                                                                     | `%Lf`                                 | `printf("%Lf", num);`  |

## Представление числа в различных системах

| Символы      | Описание                                                                       | Пример                                 |
| ------------ | ------------------------------------------------------------------------------ | -------------------------------------- |
| `0b`         | Двоичное представление числа (набор из 0 и 1)                                  | `0b1011` - число 11 в 10-ичной системе |
| `0`          | Восьмеричная система счисления (набор из цифр от 0 до 7)                       | `013` - число 11                       |
| -            | Десятичная система счисления (набор из цифр от 0 до 9)                         | `11` - число 11                        |
| `0x`или `0X` | Шестнадцатеричная система счисления (набор из цифр от 0 до 9 и бква от A до F) | `0xB` или `0XB` - число 11             |

## Определение размера типов данных

```c
#include <stdio.h>

int main()
{
  int number = 2;
  printf("sizeof(number) = %d \n", sizeof(number)); // Вывод: sizeof(number) = 4 (размер в байтах)
  return 0;
}
```

# Управляющие последовательности

| Управляющая последовательность | Описание                  |
| ------------------------------ | ------------------------- |
| `\a`                           | Подача звукового сигнала  |
| `\b`                           | Возврат назад и затирание |
| `\f`                           | Прогон страницы           |
| `\n`                           | Конец строки              |
| `\r`                           | Возврат каретки           |
| `\t`                           | Горизонтальная табуляция  |
| `\v`                           | Вертикальная табуляция    |
| `\\`                           | Обратная косая черта      |
| `\?`                           | Вопросительный знак       |
| `\'`                           | Одинарная кавычка         |
| `\"`                           | Двойная кавычка           |

Представление символов с помощью управляющей последовательности:

| Представление | Описание                                                 | Пример                                  |
| ------------- | -------------------------------------------------------- | --------------------------------------- |
| `\ooo`        | Представление символа с помощью восмеричного числа       | `\013` - вертикальная табуляция в ASCII |
| `\xhh`        | Представление символа с помощью шестнадцатеричного числа | `\xb` - вертикальная табуляция в ASCII  |

# Константы

**Константа** — это значение, которое впоследствии в процессе программы не может быть изменено.

| Константа                                                             | Описание                                                                                                | Примеры                                                       |
| --------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------- |
| **Целочисленная константы**                                           | Константы, которые имеют целочисленный тип                                                              | `123`, `123L`, `0XFUL`                                        |
| **Символьная константы**                                              | Целое число в форме одного символа в кавычках                                                           | `'x'`, `'X'`, `'\013'`, `'\xb'`                               |
| **Вещественная константы**                                            | Константы, которые имеют вещественный тип                                                               | `123.321`, `1.2345E-20l`                                      |
| **Константное выражение**                                             | Выражение, содержащее только константы (могут вычисляться в ходе компиляции, а не выполнения программы) | `#define MAXLINE 1000`                                        |
| **Строковая константа**, **строковый литерал** или просто **литерал** | Последовательность из нескольких (в частном случае ни одного) символов, заключенных в двойные кавычки   | `"I am a string"`, `""`                                       |
| **Константы перечислимого типа**                                      | Перечислимы тип определяется списком целочисленных символических констант                               | `enum boolean { NO, YES }` (первая константа - 0, вторая - 1) |

## Строковые константы

Кавычки не являются часть строки, а только ограничивают ее. Все управляющие последовательность, которые можно включить в символьные константы, допускаются в строковых, например, `\"`. Строковые константы можно сцеплять (выполнять конкатенацию) в процессе компиляции. Следующие 2 строки являются эквивалентными:

```
"hello, " "world"
"hello, world"
```

Этой возможность можно пользоваться, когда нужно распространить длинные строковые константы на несколько строк исходного кода.

Во внутреннем представлении строки в конце присутствует нулевой символ `'\0'`, так что физический объем памяти для хранения строки превышает количество символов, записанных между кавычками, на единицу.

Стандартная библиотечная `<string.h>` содержит функцию `strlen(s)`, которая возвращает количество символов в строке, переданной ей в качестве аргумента, не считая завершающего `'\0'`. 

## Константы перечислимого типа

**Перечисления** - это удобный способ ассоциировать значения констант с символическими именами с тем преимущество перед `#define`, что значения могут генерироваться автоматически.

```c
enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t' };
enum months { JAN = 1, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC }; // FEB = 2, MAR = 3, ...
```

# Объявления

В **объявлении** указываются тип и список из одной или нескольких переменных:

```c
int lower, upper, step;
char c, line[1000];
int stop;
int go;
```

Переменную можно **инициализировать** прямо в объявлениях (т.е. присвоить значение во время создания переменной):

```c
#define MAXLINE 1000

// инициализация в объявлениях
char esc = '\\';
int i = 0;
int limit = MAXLINE + 1;
float eps = 1.0e-05;
```

## Модификатор `const`

К объявлению любой переменной можно добавить модификатор `const`, чтобы значение этой переменной впоследствии не менялось. В случае массива этот модификатор запрещает изменение любого из элементов.

```c
const double e = 2.718;
const char msg[] = "warning: ";
```

Декларация `const` может употребляться с аргументами-массивами, указывая тем самым, что функция не изменяет передавайемый ей массив:

```c
int strlen(const char[]);
```

Если предпринимается попытка изменить переменную, объявленную с модификатором `const`, ее результат будет зависеть от реализации языка.

# Операции
## Арифметические операции

| Операция | Описание                                                                               | Пример               |
| -------- | -------------------------------------------------------------------------------------- | -------------------- |
| `+`      | Сложение                                                                               | `4 + 5`              |
| `-`      | Вычитание                                                                              | `4 - 5`              |
| `*`      | Умножение                                                                              | `4 * 5`              |
| `/`      | Целочисленное деление (оба операнда - целые числа, остаток от деления отбрасывается)   | `9 / 4`              |
| `/`      | Деление (оба (или один) операнда - вещественные числа, результат - вещественное число) | `9.0 / 4`, `9 / 4.0` |
| `%`      | Остаток от деления (только для целых чисел)                                            | `9 % 4`              |

## Операции отношения и логические операции

**Операции отношения** (тип операндов должен быть одинаковым):

| Операция | Описание                                                                                        | Пример              |
| -------- | ----------------------------------------------------------------------------------------------- | ------------------- |
| `>`      | Больше (вернет 1, если левый операнд больше правого, и 0 в обратном случае)                     | `4 > 5`, `10 > 2    |
| `>=`     | Больше или равно (вернет 1, если левый операнд больше или равен правому, и 0 в обратном случае) | `4 >= 4`, `10 >= 2` |
| `<`      | Меньше (вернет 1, если левый операнд меньше правого, и 0 в обратном случае)                     | `4 < 5`, `10 < 2`   |
| `<=`     | Меньше или равно (вернет 1, если левый операнд меньше или равен правому, и 0 в обратном случае) | `4 <= 5`, `10 <= 2` |
| `==`     | Равенство (вернет 1, если оба операнда равны, и 0 в обратном случае)                            | `4 == 5`, `4 == 4`  |
| `!=`     | Неравенство (вернет 1, если оба операнда не равны, и 0 в обратном случае)                       | `4 != 5`, `4 != 4`  |

**Логические операции**:

| Операция | Описание                                                                                 | Пример               |
| -------- | ---------------------------------------------------------------------------------------- | -------------------- |
| `&&`     | Операция `И` (вернет 1, если оба операнда равны 1, и 0 в обратном случае)                | `4 == 5 && 2 == 1`   |
| `\|\|`   | Операция `ИЛИ` (вернет 1, если хотя бы один операнд равны 1, и 0 в обратном случае)      | `4 == 4 \|\| 2 == 4` |
| `!`      | Операция `НЕ` (вернет значение, обратное операнду: если было 1, то станет 0, и наоборот) | `!(4 == 4)`          |

Пример использования (ввод символов из консоли в массив символов):

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
  int i, lim = 100;
  char c, s[lim];
  for (i = 0; i < lim - 1 && (c = getchar()) != '\n' && c != EOF; ++i) {
    s[i] = c;
  }
  return 0;
}
```

## Операции инкрементирования и декрементирования

**Постфиксная** инкрементация (`i++`) - добавляет единицу к операнду **после того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", i++ + j); // Вывод: 10. Сначала i + j, затем i + 1 (от инкрементации)
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 11
  return 0;
}
```

**Префиксная** инкрементация (`++i`) - добавляет единицу к операнду **до того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", ++i + j); // Вывод: 11. Сначала i + 1 (от инкрементации), затем i + j
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 11
  return 0;
}
```

**Постфиксная** декрементация (`i--`) - вычитает единицу от операнда **после того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", i-- + j); // Вывод: 10. Сначала i + j, затем i - 1 (от инкрементации)
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 9
  return 0;
}
```

**Префиксная** декрементация (`--i`) - вычитает единицу от операнда **до того**, как он используется:

```c
#include <stdio.h>

int main()
{
  int i = 0, j = 10;
  printf("%d", --i + j); // Вывод: 9. Сначала i - 1 (от инкрементации), затем i + j
  // В любом случае после использования операнда, его значение изменится на единицу.
  printf("%d", i); // Вывод: 9
  return 0;
}
```

## Поразрядные операции

| Операция | Описание                                                                                                                                                                        | Пример                                                                                                                                       |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `&`      | Порязрадное `И` (часто используется для обнуления некоторого набора битов)                                                                                                      | `n = n & 0177` - обнуляет все биты переменной `n`, кроме младших семи                                                                        |
| `\|`     | Поразрядное включающее `ИЛИ` (часто используется для того, чтобы сделать отдельные биты единицами)                                                                              | `x = x \| SET_ON` - делает единицами все биты, которые равны 1 в константе `SET_ON`                                                          |
| `^`      | Поразрядное исключающее `ИЛИ` (помещает единицу в позиции, где в операндах состоят различные биты, и нуль в те позиции, в которых биты операндов совпадают)                     | `x = 123 ^ 521`                                                                                                                              |
| `<<`     | Сдвиг влево (выполняет сдвиг своего левого операнда влево на количество разрядов (битовых позиций), заданных правым операндом, который обязательно должен быть положительным)   | `x << 2` - сдвигает значение `x` влево на две разрядные позиции, заполняя вакантные биты нулями (в итоге это то же самое, что и `x = x * 4`) |
| `>>`     | Сдвиг вправо (выполняет сдвиг своего левого операнда вправо на количество разрядов (битовых позиций), заданных правым операндом, который обязательно должен быть положительным) | `x >> 2`                                                                                                                                     |
| `~`      | Одноместное поразрядное дополнение до единицы, т.е. преобразование каждого единичного бита в нулевой и наоборот                                                                 | `x = ~077`                                                                                                                                   |

**Сдвиг вправо** числа типа `unsigned` всегда заполняет освободившиеся биты нулями. Сдвиг вправо числа со знаком в некоторых системах приводит к заполнению этих битов значением знакового бита ("арифметический сдвиг"), а в других - нулями ("логический сдвиг").

## Операции с присваиванием и выражения с ними

| Операция     | Операция с присваиванием |
| ------------ | ------------------------ |
| `i = i + 2`  | `i += 2`                 |
| `i = i - 2`  | `i -= 2`                 |
| `i = i * 2`  | `i *= 2`                 |
| `i = i / 2`  | `i /= 2`                 |
| `i = i % 2`  | `i %= 2`                 |
| `i = i << 2` | `i <<= 2`                |
| `i = i >> 2` | `i >>= 2`                |
| `i = i & 2`  | `i &= 2`                 |
| `i = i ^ 2`  | `i ^= 2`                 |
| `i = i \| 2` | `i \|= 2`                |

# Преобразование типов

Правила преобразования типов:

- Единственное корректное автоматическое преобразование типов - это то, в котором более "узкий" тип преобразуется в более "широкий" без потери информации, например, при сложении числа типа `int` с числом типа `float` (автоматически преобразуется во `float`). Преобразование происходит до выполнения операции с этими числами.
- Выражения, которые не имеют смысла, запрещены. Например, использование типа `float` в качестве индексов массива
- Выражения, в которых может произойти частичная потеря информации, могут привести к выдаче предупреждения, но не запрещены. Например, помещение числа длинного типа в переменную более короткого типа или вещественного числа в целую переменную
- Переменные типа `char` - это короткие целые числа, поэтому их можно свободно использовать в арифметических выражениях. Например, можно преобразовывать символьную строку цифр в ее смысловой эквивалент - целое число (функция [atoi](https://en.cppreference.com/w/c/string/byte/atoi)). Преобразование символов в целые числа зависит от конкретной системы.

## Расширение целочисленных типов

Если `int` позволяет представить все значения исходного типа операнда, то операнд приводится к `int`, в противном случае - к `unsigned int`. Эта процедура называется **расширение целочисленного типа** (integral promotion)

## Преобразование целочисленных типов

Чтобы привести целое число к некоторому заданному типу без знака, ищется конгруэнтное (т.е. имеющее то же двоичное представление) наименьшее неотрицательное значение, а затем получается остаток от деления его на `UMAX + 1`, где `UMAX` - наибольшее число в данном типе без знака. При использовании двоичного представления в дополнительном коде ("дополнения к двойке") для этого либо отбрасываются лишние левые разряды, если двоичное представление беззнакового типа уступает в длине исходному типу, либо недостающие старшие разряды заполняются нулями (в числах без знака) или значением знака (в числах со знаком), если тип без знака шире исходного.

В результате приведения целого числа к знаковому типу его значение не изменяется, если оно представимо в этом новом типе; в противном случае результат зависит от реализации.

## Преобразование целых чисел в вещественные и наоборот

При преобразовании из вещественного типа в целочисленный дробная часть числа отбрасывается; если полученное при этом значение нельзя представить величиной заданного целочисленного типа, то результат не определен. В частности, не определен результат преобразования отрицательных чисел с плавающей точкой в целые числа без знака.

Если число преобразуется из целого в вещественное и находится в допустимом диапазоне, но представляется в новом типе недостаточно точно, то результатом будет большее или меньшее ближайшее значение нового типа. Если результат выходит за границы диапазона допустимых значений, результат не определен.

## Вещественные типы

При преобразовании из вещественного типа меньшей точности к типу большей точности число не изменяется. Если же преобразование выполняется от большей точности к меньшей и число остается в допустимых пределах нового типа, то результатом будет большее или меньшее ближайшее значение нового типа. Если результат выходит за границы допустимого диапазона, результат не определен.

## Арифметические преобразования

Во многих операциях преобразование типов операндов и определение типа результата следуют одной и той же схеме. В результате операнды приводятся к некоторому общему типу, который также является и типом результата. Эта схема включает в себя **обычные арифметические преобразования**:

- Если какой-либо из операндов имеет тип `long double`, то и другой приводится к `long double`
- Иначе, если какой-либо из операндов имеет тип `double`, то и другой приводится к `double`
- Иначе, если какой-либо из операндов имеет тип `float`, то и другой приводится к `float`
- Иначе, если один из операндов имеет тип `unsigned long int`, то и другой приводится к `unsigned long int`
- Иначе, если один из операндов имеет тип `long int`, а другой `unsigned int`, то результат зависит от того, представляет ли `long int` все значения `unsigned int`:
  - Если да, то операнд типа `unsigned int` приводится к `long int`
  - Если нет, то оба операнда преобразуются в `unsigned long int`
- Иначе, если один из операндов имеет тип `long int`, то и другой приводится к `long int`
- Иначе, если один из операндов имеет тип `unsigned int`, то и другой приводится к `unsigned int`
- Иначе, оба операнда имеют тип `int`

## Явное приведение типов

```
(имя-тип) выражение
```

Например:

```c
int n = 10;
sqrt((double) n);
```

# Условные выражения

```c
#include <stdio.h>

int main()
{
  int a = 2, b = 3, z;
  // Условное выражение
  if (a > b) // Если a больше b, то выполняем следующий блок
  {
    z = a;
  }
  else // В противном случае выполняем этот блок
  {
    z = b;
  }
  return 0;
}
```

Это условное выражение можно записать с помощью трехместной операции `?:` (**тернарный оператор**):

```c
#include <stdio.h>

int main()
{
  int a = 2, b = 3;
  // Условное выражение с трехместной операцией 
  int z = (a > b) ? a : b;
  return 0;
}
```

# Приоритет и порядок вычисления

> В самом верху таблицы операции имеют высший приоритет, а в самом низу таблицу самый низкий приоритет (т.е. выполняются в последнюю очередь).

|Операции|Ассоциирование|
|---|---|
|`()` (вызов функции), `[]`, `->` (обращение к элементам структур), `.` (обращение к элементам структур)|Слева направо|
|`!`, `~`, `++`, `--`, `+` (унарный плюс), `-` (унарный минус), `*` (ссылка по указателю), `&` (получение адреса объекта), `(тип)` (преобразование к типу), `sizeof` (вычисление размера объекта)|Справа налево|
|`*`, `/`, `%`|Слева направо|
|`+`, `-`|Слева направо|
|`<<`, `>>`|Слева направо|
|`<`, `<=`, `>`, `>=`|Слева направо|
|`==`, `!=`|Слева направо|
|`&`|Слева направо|
|`^`|Слева направо|
|`\|`|Слева направо|
|`&&`|Слева направо|
|`\|\|`|Слева направо|
|`?:` (тернарный оператор)|Справа налево|
|`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `\|=`, `<<=`, `>>=`|Справа налево|
|`,` (оператор запятая)|Слева направо|